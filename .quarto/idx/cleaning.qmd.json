{"title":"Cleaning the Data","markdown":{"headingText":"Cleaning the Data","headingAttr":{"id":"","classes":["unnumbered"],"keyvalue":[]},"containsRefs":false,"markdown":"\nHere is how we loaded and cleaned the data, and the problems that arose in the process.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"R and DuckDB Setup\"\n#| warning: FALSE\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(gt)\nlibrary(reticulate)\n\nlibrary(DBI)\nlibrary(duckdb)\noptions(duckdb.enable_rstudio_connection_pane=TRUE)\n\ndrv <- duckdb()\ncon <- dbConnect(drv)\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: \"Python Setup\"\n# py_install(\"pandas\")\nimport pandas as pd\nimport numpy as np\nimport great_tables as gt #this makes the python tables look nice\nimport warnings #this is to silence a warning about using .replace later in the code\nfrom great_tables import GT\nwarnings.simplefilter(action='ignore', category=FutureWarning)\n```\n\n### Read the Tables from csv Files \n\nThese are the tables before cleaning and combining. Lots of unnecessary columns and inconsistent headings between the tables. Another issue to address is the quotations around the song titles on the Billboard chart. The song titles and artist names are also not consistent across tables. \n\n::: panel-tabset\n\n#### R\nReading the csv files is pretty simple in R. <code>read_csv</code> reads the csv and the output can be saved. <code>show_col_types = FALSE</code> hides the console output that shows a count of the rows and columns and if the column is a chr, dbl, etc. \n```{r reading files}\n#| code-fold: true\n#| code-summary: \"Spotify\"\nspotify_charts <- read_csv(\"initial_tables/spotify_top_charts_22.csv\", show_col_types = FALSE)\nspotify_charts\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"TikTok\"\ntiktok_charts <- read_csv(\"initial_tables/TikTok_songs_2022.csv\", show_col_types = FALSE)\ntiktok_charts\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Billboard\"\nbillboard_charts <- read_csv(\"initial_tables/Billboard_hot_100_year_end_2022.csv\", show_col_types = FALSE)\nbillboard_charts\n```\n\n#### SQL\nThis code makes (or replaces) a table from the csv file. <code>SELECT *</code> means that all columns in the csv will be brought over into the table. The tables only show five rows so that they do not take up too much of the page. \n```{sql}\n#| connection: con\nCREATE OR REPLACE TABLE spotify_charts AS\n  SELECT * FROM 'initial_tables/spotify_top_charts_22.csv';\n```\n\n```{sql}\n#| connection: con\nSELECT * FROM spotify_charts\nLIMIT 5; --only show five rows\n```\n\n```{sql}\n#| connection: con\nCREATE OR REPLACE TABLE tiktok_charts AS\n  SELECT * FROM 'initial_tables/TikTok_songs_2022.csv';\n```\n\n```{sql}\n#| connection: con\nSELECT * FROM tiktok_charts\nLIMIT 5; --only show five rows\n```\n\n```{sql}\n#| connection: con\nCREATE OR REPLACE TABLE billboard_charts AS\n  SELECT * FROM 'initial_tables/Billboard_hot_100_year_end_2022.csv';\n```\n\n```{sql}\n#| connection: con\nSELECT * FROM billboard_charts\nLIMIT 5; --only show five rows\n```\n\n#### Python\nMaking the tables in Python is very similar to R. <code>pd.read_csv</code> reads the csv file and returns a DataFrame.\n```{python}\n#| code-fold: true\n#| code-summary: \"Billboard\"\nspotify_charts = pd.read_csv(\"initial_tables/spotify_top_charts_22.csv\")\nspotify_charts\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: \"Billboard\"\ntiktok_charts = pd.read_csv(\"initial_tables/TikTok_songs_2022.csv\")\ntiktok_charts\n```\n\n```{python}\n#| code-fold: true\n#| code-summary: \"Billboard\"\nbillboard_charts = pd.read_csv(\"initial_tables/Billboard_hot_100_year_end_2022.csv\")\nbillboard_charts\n```\n:::\n\n\n### Cleaning\n\nAll the tables are messy. Both the Spotify and TikTok tables have columns that are not necessary for this project. To keep the tables simple, we cleaned the data to make all three tables as similar as possible. We renamed all the columns holding the song title to <code>song_title</code>, the artist(s) <code>artist</code>, and the popularity/rank to <code>rank_s/rank_t/rank_b</code> for Spotify, TikTok, and Billboard, respectively. We also included the <code>tempo</code> column on the Spotify and TikTok tables. The quotations are also removed from the song titles in the Billboard chart as well. \n\n#### Spotify\nFor the spotify_charts, we filterd to keep on the the columns containing the song title, artist anme, peak rank, and tempo. We reordered and renamed the columns as follows: song_title, artist, rank_s, and tempo. The <code>rank_s</code> column indicated the highest rank the song appeared on the chart, so a lower number indicated that the song was more popular.\n\n::: panel-tabset\n\n##### R\nFor the Spotify data, we used <code>select()</code> to only keep the relevant columns.\n```{r}\nspotify_cleaned <- spotify_charts |> \n  clean_names() |> #clean the column headers\n  select(track_name, artist_names, peak_rank, tempo) |> #select only certain columns\n  rename(song_title = track_name, artist = artist_names, rank_s = peak_rank) |>\n  arrange(rank_s) #order from most to least popular (lower number = more popular)\n\nspotify_cleaned\n```\n\n##### SQL\nSimilar to in R, we used <code>SELECT</code> to only keep the relevant columns and used <code>ORDER BY</code> to arrange the rows from most to least popular. \n```{sql clean spotify sql}\n#| connection: con\n--select only relevant columns and rename them appropriately\nCREATE OR REPLACE TABLE spotify_cleaned AS\n  SELECT track_name AS song_title, artist_names AS artist, peak_rank AS rank_s, tempo\n  FROM spotify_charts\n;\n--order from most to least popular using the rank_s column (lower number = more popular)\nFROM spotify_cleaned\nORDER BY rank_s ASC\n```\n\n##### Python\nFor the Spotify data, we used <code>.filter</code> to only keep the relevant columns and <code>.sort_values</code> to sort the rows. \n```{python}\nspotify_cleaned = (spotify_charts\n                   .filter(items = ['track_name', 'artist_names', 'peak_rank', 'tempo'])\n                   .rename(columns = {'track_name': 'song_title',\n                                      'artist_names': 'artist',\n                                      'peak_rank': 'rank_s'})\n                   .sort_values('rank_s') # lower number = higher rank\n                  )\nspotify_cleaned\n```\n\n:::\n\n#### TikTok\n\nSimilar to the Spotify dataset, we kept only the relevant columns and renamed them to be the same as the Spotify dataset. The <code>rank_t</code> column indicates the popularity of a song, with a higher value indicating that the song achieved greater popularity.\n\n::: panel-tabset\n\n##### R\n```{r}\ntiktok_cleaned <- tiktok_charts |>\n  clean_names() |> #clean the column headers\n  select(track_name, artist_name, track_pop, tempo) |> #filter for certain columns\n  rename(song_title = track_name, artist = artist_name, rank_t = track_pop) |>\n  arrange(desc(rank_t)) #arrange by popularity (higher number = more popular)\n\ntiktok_cleaned\n```\n\n##### SQL\n```{sql clean tiktok}\n#| connection: con\n--create a cleaned version of the tiktok table and select only relevant columns\nCREATE OR REPLACE TABLE tiktok_cleaned AS\n  SELECT track_name AS song_title, artist_name AS artist, track_pop AS rank_t, tempo\n  FROM tiktok_charts\n;\n--order from most to least popular using the rank_t column\nFROM tiktok_cleaned\nORDER BY rank_t DESC\n```\n\n##### Python\n```{python}\ntiktok_cleaned = (tiktok_charts\n                   .filter(items = ['track_name', 'artist_name', 'track_pop', 'tempo'])\n                   .rename(columns = {'track_name': 'song_title',\n                                      'artist_name': 'artist',\n                                      'track_pop': 'rank_t'})\n                   .sort_values('rank_t', ascending=False) # higher numbers = more popular\n                  )\n                  \ntiktok_cleaned\n```\n\n:::\n\n#### Billboard\n\nThe billboard_chart was almost the same as the previous two tables. The columsn kept are the columns containing the song title, artist, and rank. The columns were named <code>song_title</code>, <code>artist</code>, and <code>rank_b</code>. The <code>rank_b</code> column indicated the rank of the song, with a lower number indicating a song that achieved a higher rank. \n\n::: panel-tabset\n\n##### R\n```{r}\nbillboard_cleaned <- billboard_charts |>\n  clean_names() |> #clean the column headers\n  select(title, artist_s, no) |> #reorder the columns\n  rename(song_title = title, rank_b = no, artist = artist_s) |> \n  mutate(song_title = str_replace_all(song_title, '\"', '')) #take quotations off song titles\n\nbillboard_cleaned\n```\n\n##### SQL\n```{sql}\n#| connection: con\n--create a cleaned version of the billboard table and select only renamed relevant columns\nCREATE OR REPLACE TABLE billboard_cleaned AS\n  SELECT replace(title, '\"', '') AS song_title, \"artist(s)\" AS artist, \"no.\" AS rank_b\n  FROM billboard_charts\n;\n--order from most to least popular using the rank_b column\nFROM billboard_cleaned\nORDER BY rank_b\n```\n\n##### Python\n```{python}\nbillboard_cleaned = (billboard_charts\n                   .rename(columns = {'Title': 'song_title',\n                                      'Artist(s)': 'artist',\n                                      'No.': 'rank_b'})\n                   .sort_values('rank_b') # highest to lowest rank\n                  )\nbillboard_cleaned['song_title'] = billboard_cleaned['song_title'].str.replace('\"', '')\n\nbillboard_cleaned\n```\n:::\n\n## Challenges\n\nTwo challenges stood out to us, both involving the variations in the way that the song metadata is recorded on the charts. The same song can appear on different albums with slgiht variations of the title, or can have a featured artist listed in the title or as an additional artist, or could be a cover of another song, etc. As an example, the song \"Enemy\" by Imagine Dragons appears twice on the Spotify chart, once on the TikTok chart, and once on the Billboard chart:\n\n::: panel-tabset\n\n#### R\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nspotify_cleaned |>\n  filter(str_detect(song_title, 'Enemy')) #filter for song titles containing \"Enemy\"\ntiktok_cleaned |>\n  filter(str_detect(song_title, 'Enemy'))\nbillboard_cleaned |>\n  filter(str_detect(song_title, 'Enemy'))\n```\n#### SQL\n```{sql Enemy on the S Charts}\n#| connection: con\n#| code-fold: true\n#| code-summary: \"Spotify\"\nSELECT *\nFROM spotify_cleaned\nWHERE song_title LIKE '%Enemy%'\n```\n\n```{sql Enemy on the T Charts}\n#| connection: con\n#| code-fold: true\n#| code-summary: \"TikTok\"\nSELECT *\nFROM tiktok_cleaned\nWHERE song_title LIKE '%Enemy%'\n```\n\n```{sql Enemy on the B Charts}\n#| connection: con\n#| code-fold: true\n#| code-summary: \"Billboard\"\nSELECT *\nFROM billboard_cleaned\nWHERE song_title LIKE '%Enemy%'\n```\n\n#### Python\n```{python}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nGT(spotify_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\nGT(tiktok_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\nGT(billboard_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\n```\n\n:::\n\nAll three charts record the song title differently. The Spotify chart has two different versions of \"Enemy\" on it: one with JID and one without, so leaving those titles as is is fine. The TikTok and Billboard charts both have the version with JID, but the name of the song and artists listed are different. To handle these synonyms, we created a lookup table and applied it to each dataset. We chose to apply the dictionary to each individual table rather than a combined table so that when we combine the tables, songs with the same title and artists would be combined. The tables for the song titles and artist names were created in Google Sheets and uploaded to RStudio as csv files.\n\n### Change Song Titles\n\nThe process in the three languages was essentially the same. We read the csv file and stored the resulting table. Then we merged/joined the lookup table with each chart. The lookup table has two columns: one containing the canonical names and another containing the alternative names. \n\n::: panel-tabset\n\n#### R\n\nRead the lookup table. \n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nsong_title_lookup <- read_csv(\"initial_tables/dict_song_titles.csv\", show_col_types = FALSE)\nsong_title_lookup\n```\n\nWe used a <code>left_join</code> and joined on the <code>song_title</code> column of the song chart on the <code>alt_name</code> column of the lookup table. This join created a new column called <code>canonical_name</code> on the chart. <code>mutate</code> is used to replace the value in the song_title columns with the name in the <code>canonical_name</code>, if there is one. <code>coalesce</code> takes the first non-null value, so if the <code>canonical_name</code> column is empty, then the song title will not be replaced. \n\n```{r}\nspotify_cleaned <- spotify_cleaned |>\n  left_join(song_title_lookup, by = join_by(song_title == alt_name)) |>\n  mutate(song_title = coalesce(canonical_name, song_title)) |> #coalesce takes the first non-null value\n  select(song_title, artist, rank_s, tempo) #keep only relevant columns\n```\n\n```{r}\ntiktok_cleaned <- tiktok_cleaned |>\n  left_join(song_title_lookup, by = join_by(song_title == alt_name)) |>\n  mutate(song_title = coalesce(canonical_name, song_title)) |>\n  select(song_title, artist, rank_t, tempo)\n```\n\n```{r}\nbillboard_cleaned <- billboard_cleaned |>\n  left_join(song_title_lookup, by = join_by(song_title == alt_name)) |> \n  mutate(song_title = coalesce(canonical_name, song_title)) |>\n  select(song_title, artist, rank_b)\n```\n\n#### SQL\n\nRead the look table csv and create a table.\n\n```{sql}\n#| connection: con\nCREATE OR REPLACE TABLE song_title_lookup AS\n  SELECT * \n  FROM 'initial_tables/dict_song_titles.csv';\n```\n\nWe used <code>UPDATE</code> to avoid having to coalesce columns. This code checks if a song listed in the song title column in the chart is the same as a song listed in the alt_name column of the lookup table. If there is a match, then the song title is replaced with the song from the canonical_name column of the lookup table.  \n\n```{sql}\n#| connection: con\nUPDATE spotify_cleaned\n  SET song_title = song_title_lookup.canonical_name\n  FROM song_title_lookup\n  WHERE spotify_cleaned.song_title = song_title_lookup.alt_name\n```\n\n```{sql}\n#| connection: con\nUPDATE tiktok_cleaned\n  SET song_title = song_title_lookup.canonical_name\n  FROM song_title_lookup\n  WHERE tiktok_cleaned.song_title = song_title_lookup.alt_name\n```\n\n```{sql}\n#| connection: con\nUPDATE billboard_cleaned\n  SET song_title = song_title_lookup.canonical_name\n  FROM song_title_lookup\n  WHERE billboard_cleaned.song_title = song_title_lookup.alt_name\n```\n\n#### Python w/ Merge\n\nWe have two different methods in Python here. This method uses <code>.merge</code> and is similar to the R version. The lookup table csv file is read. Then the chart table and the lookup table are left-merged on the song_title and alt_name. This creates two new columns in the chart called canonical_name and alt_name. If there is a value in the alt_name columns, the the value from the canonical_name column replaces the song_title. \n\n```{python}\nsong_syn = pd.read_csv('initial_tables/dict_song_titles.csv')\n\n# Spotify\nspotify_cleaned = spotify_cleaned.merge(song_syn, left_on = 'song_title', right_on = 'alt_name', how = 'left')\n\nspotify_cleaned['song_title'] = np.where( #if the alt_name column has a value then, replace song_title with canonical_name\n   spotify_cleaned['alt_name'].notna(), \n   spotify_cleaned['canonical_name'], \n   spotify_cleaned['song_title'])\n   \nspotify_cleaned = spotify_cleaned.drop(columns = ['canonical_name', 'alt_name']) # remove unnecessary columns\n\n\n# TikTok\ntiktok_cleaned = tiktok_cleaned.merge(song_syn, left_on = 'song_title', right_on = 'alt_name', how = 'left')\n\ntiktok_cleaned['song_title'] = np.where(\n   tiktok_cleaned['alt_name'].notna(), \n   tiktok_cleaned['canonical_name'], \n   tiktok_cleaned['song_title'])\n   \ntiktok_cleaned = tiktok_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n\n\n# Billboard\nbillboard_cleaned = billboard_cleaned.merge(song_syn, left_on = 'song_title', right_on = 'alt_name', how = 'left')\n\nbillboard_cleaned['song_title'] = np.where(\n   billboard_cleaned['alt_name'].notna(), \n   billboard_cleaned['canonical_name'], \n   billboard_cleaned['song_title'])\n   \nbillboard_cleaned = billboard_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n```\n\n#### Python w/ Replace\n\nThe second Python method uses <code>.replace</code>. This method was my initial inclination regarding how to recode the charts, but is not the best appraoch to this problem. This method works be converting the lookup table csv file into a dictionary of keys and values. The alt_name column is set as the index and is mapped to the canonical_name column. <code>to_dict</code> converts the result to a dictionary. \n\n<code>.replace</code> looks for the song title in the keys of the dictionary and replaces the song_title with the canonical name from the dictionary. <code>inplace</code> modifies the original DataFrame directly. Using it spits out a \"future warning\" because there are planned changes for <code>inplace</code>.\n\n```{python}\n# import the table and convert to a dictionary using to.dict()\nsong_title_dict = pd.read_csv('initial_tables/dict_song_titles.csv', header=0).set_index('alt_name')['canonical_name'].to_dict()\n\n# replace the song_title with the canonical_name\nspotify_cleaned['song_title'].replace(song_title_dict, inplace = True)\ntiktok_cleaned['song_title'].replace(song_title_dict, inplace = True)\nbillboard_cleaned['song_title'].replace(song_title_dict, inplace = True)\n```\n\n:::\n\n### Change Artist Names\n\nThe we did the exact same thing but for the artist names. The lookup table in this instance had two columns: canonical_name and alt_name. The process was essentially the same as changing the song titles. \n\n::: panel-tabset\n\n#### R\n```{r import name dictionary}\ndict_artist <- read_csv(\"initial_tables/dict_artist.csv\", show_col_types = FALSE)\ndict_artist\n```\n\n```{r}\nspotify_cleaned <- spotify_cleaned |>\n  left_join(dict_artist, by = join_by(artist == alt_name)) |>\n  mutate(song_title = coalesce(canonical_name, song_title)) |>\n  select(song_title, artist, rank_s, tempo)\n```\n\n```{r}\ntiktok_cleaned <- tiktok_cleaned |>\n  left_join(dict_artist, by = join_by(artist == alt_name)) |>\n  mutate(song_title = coalesce(canonical_name, song_title)) |>\n  select(song_title, artist, rank_t, tempo)\n```\n\n```{r}\nbillboard_cleaned <- billboard_cleaned |>\n  left_join(dict_artist, by = join_by(artist == alt_name)) |>\n  mutate(song_title = coalesce(canonical_name, song_title)) |>\n  select(song_title, artist, rank_b)\n```\n\n```{r, include=FALSE}\nsaveRDS(spotify_cleaned, \"working_tables/spotify_cleaned.rds\")\nsaveRDS(tiktok_cleaned, \"working_tables/tiktok_cleaned.rds\")\nsaveRDS(billboard_cleaned, \"working_tables/billboard_cleaned.rds\")\n```\n\n#### SQL\n```{sql}\n#| connection: con\nCREATE TABLE dict_artist AS\n  SELECT * FROM 'initial_tables/dict_artist.csv';\n```\n\n```{sql}\n#| connection: con\nUPDATE spotify_cleaned\n  SET artist = dict_artist.canonical_name\n  FROM dict_artist\n  WHERE spotify_cleaned.artist = dict_artist.alt_name\n```\n\n```{sql}\n#| connection: con\nUPDATE tiktok_cleaned\n  SET artist = dict_artist.canonical_name\n  FROM dict_artist\n  WHERE tiktok_cleaned.artist = dict_artist.alt_name\n```\n\n```{sql}\n#| connection: con\nUPDATE billboard_cleaned \n  SET artist = dict_artist.canonical_name\n  FROM dict_artist\n  WHERE billboard_cleaned.artist = dict_artist.alt_name\n```\n\n```{sql, include=FALSE}\n#| connection: con\nCOPY spotify_cleaned TO 'working_tables/spotify_cleaned_sql.csv' (HEADER, DELIMITER ',');\nCOPY tiktok_cleaned TO 'working_tables/tiktok_cleaned_sql.csv' (HEADER, DELIMITER ',');\nCOPY billboard_cleaned TO 'working_tables/billboard_cleaned_sql.csv' (HEADER, DELIMITER ',');\n```\n\n#### Python w/ Merge\n\n```{python}\ndict_artist = pd.read_csv('initial_tables/dict_artist.csv')\n\n# Spotify\nspotify_cleaned = spotify_cleaned.merge(dict_artist, left_on = 'artist', right_on = 'alt_name', how = 'left')\nspotify_cleaned['artist'] = np.where( #if the alt_name column has a value then, replace artist with canonical_name\n   spotify_cleaned['alt_name'].notna(), \n   spotify_cleaned['canonical_name'], \n   spotify_cleaned['artist'])\nspotify_cleaned = spotify_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n\n# TikTok\ntiktok_cleaned = tiktok_cleaned.merge(dict_artist, left_on = 'artist', right_on = 'alt_name', how = 'left')\ntiktok_cleaned['artist'] = np.where(\n   tiktok_cleaned['alt_name'].notna(), \n   tiktok_cleaned['canonical_name'], \n   tiktok_cleaned['artist'])\ntiktok_cleaned = tiktok_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n\n# Billboard\nbillboard_cleaned = billboard_cleaned.merge(dict_artist, left_on = 'artist', right_on = 'alt_name', how = 'left')\nbillboard_cleaned['artist'] = np.where(\n   billboard_cleaned['alt_name'].notna(), \n   billboard_cleaned['canonical_name'], \n   billboard_cleaned['artist'])\nbillboard_cleaned = billboard_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n```\n\n#### Python w/ Replace\n\n```{python}\ndict_artist = pd.read_csv('initial_tables/dict_artist.csv', header=0).set_index('alt_name')['canonical_name'].to_dict()\n\nspotify_cleaned['artist'].replace(dict_artist, inplace = True)\ntiktok_cleaned['artist'].replace(dict_artist, inplace = True)\nbillboard_cleaned['artist'].replace(dict_artist, inplace = True)\n```\n\n```{python, include=FALSE}\nspotify_cleaned.to_csv(\"working_tables/spotify_cleaned_py.csv\", index=False, header=True, sep=',',)\ntiktok_cleaned.to_csv(\"working_tables/tiktok_cleaned_py.csv\", index=False)\nbillboard_cleaned.to_csv(\"working_tables/billboard_cleaned_py.csv\", index=False)\n```\n\n:::\n\n### Examples of the Changes\n\nWe did not print the tables above as they would have looked nearly identical to the original tables. Only a few songs out of about 900 songs were changed, so the changes would be difficult to see if the entire table was printed. Here is the same example from above using \"Enemy.\"\n\n::: panel-tabset\n\n#### R\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nspotify_cleaned |>\n  filter(str_detect(song_title, 'Enemy')) #filter for song titles containing \"Enemy\"\ntiktok_cleaned |>\n  filter(str_detect(song_title, 'Enemy'))\nbillboard_cleaned |>\n  filter(str_detect(song_title, 'Enemy'))\n```\n#### SQL\n```{sql}\n#| connection: con\n#| code-fold: true\n#| code-summary: \"Spotify\"\nSELECT *\nFROM spotify_cleaned\nWHERE song_title LIKE '%Enemy%'\n```\n\n```{sql}\n#| connection: con\n#| code-fold: true\n#| code-summary: \"TikTok\"\nSELECT *\nFROM tiktok_cleaned\nWHERE song_title LIKE '%Enemy%'\n```\n\n```{sql}\n#| connection: con\n#| code-fold: true\n#| code-summary: \"Billboard\"\nSELECT *\nFROM billboard_cleaned\nWHERE song_title LIKE '%Enemy%'\n```\n\n#### Python\n```{python}\n#| code-fold: true\n#| code-summary: \"Show the code\"\nGT(spotify_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\nGT(tiktok_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\nGT(billboard_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\n```\n\n:::\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":true,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","self-contained":true,"output-file":"cleaning.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","code_folding":"hide","code_summary":"Show the code"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}