{
  "hash": "14a737abd497047978dcabba31d161ac",
  "result": {
    "engine": "knitr",
    "markdown": "## Discritized Table {.unnumbered}\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n--------------------------------------------------------------------------------\n\nAs explained earlier, the ranking system for each dataset was slightly different. The rank for songs on the Spotify chart <code>rank_s</code> ranges from 1 to 200. The value is the number that the Spotify algorithm uses to determine popularity. The rank for the TikTok charts <code>rank_t</code> ranges from 0 to 100. The value represents the highest rank on the chart that the song reached. A value of 1 would mean that the song reached the highest place on the chart. The documentation does not describe what a value of 0 means. We assume that it could mean that the song made it to the chart, but did not place highly. The rank for the Billboard chart <code>rank_b</code> ranges from 1 to 100. A value of 1 means that the song was ranked the highest on the chart and a value of 100 means that the song was last on the chart. Because these ranking systems are different, we created a table that has discretized values rather than numbers.\n\nThe term \"Most popular\" was applied to the 10% most popular songs on each chart, \"Popular\" to the top 50%, and \"On chart\" to the remaining values that were not NA.\n\n### Discretizing the Tables\n\n::: panel-tabset\n\n#### R\n\nThis code calculates the percent rank for rank_s, rank_t, and rank_b, then uses a <code>case_when</code> to assign a label to each value. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined_discretized <- combined_cleaned |> \n# Spotify\n  mutate(rank_s_percent = percent_rank(rank_s)) |> # get the percent rank for each observation\n  mutate(rank_s_label = case_when( # spotify rank_s shows the highest the song reached on the chart (lower number = more popular)\n    rank_s_percent < 0.10 ~ \"Most popular\",\n    rank_s_percent <= 0.50 ~ \"Popular\",\n    rank_s_percent > 0.50 ~ \"On chart\"\n    )) |>\n  \n#TikTok\n  mutate(rank_t_percent = percent_rank(rank_t)) |> # get the percent rank for each observation\n  mutate(rank_t_label = case_when( # tiktok rank_t shows the value that the algorithm eats (higher number = more popular)\n    rank_t_percent > 0.90 ~ \"Most popular\",\n    rank_t_percent >= 0.50 ~ \"Popular\",\n    rank_t_percent < 0.50 ~ \"On chart\"\n    )) |>\n\n#Billboard\n  mutate(rank_b_percent = percent_rank(rank_b)) |> # get the percent rank for each observation\n  mutate(rank_b_label = case_when( # billboard rank_b shows the rank (lower number = high rank)\n    rank_b_percent < 0.10 ~ \"Most popular\",\n    rank_b_percent <= 0.50 ~ \"Popular\",\n    rank_b_percent > 0.50 ~ \"On chart\"\n    )) |>\n  \n  select(song_title, artist, rank_s, rank_s_label, rank_t, rank_t_label, rank_b, rank_b_label, tempo)\n```\n:::\n\n\n\n\n\n#### SQL\n\nThe function <code>percent_rank</code> is the relative position of the value in the sorted dataset. The statements below use <code>percent_rank</code> to determine if a song is the top x% and classifies the song accordingly. First a temporary table is made with the labels for the rank_s column. Then the labels for rank_t are added to that table, creating yet another temporary table in the process. Finally the labels for rank_b are added and the result is the final discretized table. \n\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n--Spotify labels\nCREATE OR REPLACE TEMP TABLE disc_s AS\n  SELECT *,\n         percent_rank() OVER (ORDER BY rank_s) AS rank_s_percent,\n     CASE \n         WHEN rank_s_percent < 10 THEN 'Most popular'\n         WHEN percent_rank() OVER (ORDER BY rank_s) <= 50 THEN 'Popular'\n         ELSE 'On chart'\n     END\n    AS rank_s_label\n  FROM combined_cleaned\n;\n\n--TikTok labels added to the table with the Spotify labels\nCREATE OR REPLACE TEMP TABLE disc_s_t AS\n  SELECT *,\n         percent_rank() OVER (ORDER BY rank_t) AS rank_t_percent,\n     CASE \n         WHEN rank_t_percent > 90 THEN 'Most popular'\n         WHEN percent_rank() OVER (ORDER BY rank_t) >= 50 THEN 'Popular'\n         ELSE 'On chart'\n     END\n    AS rank_t_label\n  FROM disc_s\n\n;\n--Billboard labels added to the table with the Spotify and TikTok labels\nCREATE OR REPLACE TABLE discretized AS\n  SELECT *,\n     percent_rank() OVER (ORDER BY rank_b) AS rank_b_percent,\n     CASE \n         WHEN rank_b_percent < 10 THEN 'Most popular'\n         WHEN percent_rank() OVER (ORDER BY rank_b) <= 50 THEN 'Popular'\n         ELSE 'On chart'\n     END\n    AS rank_b_label\n  FROM disc_s_t\n```\n:::\n\n\n\n\n\n#### Python\n\n<code>pd.qcut</code> discretizes variables into buckets based on rank or quantiles. In this case, the data is being put into buckets based on the specified quantiles of 0%-10%, 10%-50%, and 50%-100%.\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncombined['rank_s_label'] = pd.qcut(combined['rank_s'], q=[0, 0.50, 0.90, 1], labels=[\"On chart\", \"Popular\", \"Most popular\"])\ncombined['rank_t_label'] = pd.qcut(combined['rank_t'], q=[0, 0.10, 0.50, 1], labels=[\"Most popular\", \"Popular\", \"On chart\"])\ncombined['rank_b_label'] = pd.qcut(combined['rank_b'], q=[0, 0.10, 0.50, 1], labels=[\"Most popular\", \"Popular\", \"On chart\"])\ncombined\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                      song_title  ... rank_b_label\n0                                 'Til You Can't  ...      Popular\n1                               'Till I Collapse  ...          NaN\n2    1, 2, 3 (feat. Jason Derulo & De La Ghetto)  ...          NaN\n3    1, 2, 3 (feat. Jason Derulo & De La Ghetto)  ...          NaN\n4                     10 Things I Hate About You  ...          NaN\n..                                           ...  ...          ...\n924                                      traitor  ...          NaN\n925            up at night (feat. justin bieber)  ...          NaN\n926                                    vice city  ...          NaN\n927                           you broke me first  ...          NaN\n928                                        Ä°mdat  ...          NaN\n\n[929 rows x 9 columns]\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\nThe discretized table makes the data easier to compare in a glance. While the following analysis will use the un-discretized table, this table is helpful in quickly verifying that we have sorted the rows appropriately.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}