[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Popular Songs on TikTok and Beyond",
    "section": "",
    "text": "Project Goals\nThe goal of this project is to explore the intersection of the top songs on the social media platform TikTok and song charts (Spotify top songs and the Billboard Hot 100) for the year 2022. We are interested in analyzing if top songs on TikTok made it to the charts, or vice versa. We are also looking at the tempo of the songs to identify any patterns among the tempo of songs and popularity on TikTok.\nThe data sources include a table of top songs on Spotify, top songs on TikTok, and the Billboard Hot 100. Both the Spotify and TikTok tables were found on Kaggle and have data scraped from Spotify. The Billboard Hot 100 table was found on Wikipedia with the data originating from Billboard. All three charts rank songs in slightly different ways as explained below.\nBoth the Spotify and TikTok datasets have many extra columns that will be unnecessary for the scope of this project. There are also variations in the headers of the datasets and in the way that track names and artist names are listed. The easiest way approach these tables is to eliminate the unnecessary columns and rename the headers so that the tables can be compared. Another problems is comparing the rankings. Since all three charts have different ranking systems, the values cannot be directly compared. A solution is to discretize the rankings so that they can be compared.\nThis project cleans, transforms, and analyses the datasets in R, SQL, and Python. Many of the operations could be performed in the three languages.",
    "crumbs": [
      "Project Goals"
    ]
  },
  {
    "objectID": "index.html#project-goals",
    "href": "index.html#project-goals",
    "title": "Popular Songs on TikTok and Beyond",
    "section": "",
    "text": "Spotify DataTikTok DataBillboard Data\n\n\nThis table was found on Kaggle.The user who uploaded the data to Kaggle used Spotify’s API to scrape the data. The table features 17 columns and 646 observations. The grain of the table is a song and its attributes (rank, tempo, artist, dancability, etc.). For the purpose of this project, the most relevant columns are the track_name, artist_name, peak_rank, and tempo. The peak_rank column indicated the highest the song climbed on the chart. A lower number indicated that the song reached a higher ranking.\n\n\n\nTop Songs on Spotify\n\n\n\n\n\nThis dataset was found on Kaggle. The user who uploaded this data to Kaggle retrieved the data from a playlist on Spotify of trending songs on TikTok. Spotify has an API that allows users to scrape data. This table features 18 columns and 263 observations. The grain of the table is a song and its attributes (artist, mode, track_pop, etc.). The columns most relevant this project are the track_name, artist_name, track_pop, and tempo. The track_pop column represents the popularity of the song. The values in the column are produced and used by Spotify’s algorithm, with a higher number indicating that the track was more popular.\n\n\n\n\nTop Songs on TikTok\n\n\n\n\nThis dataset was found on Wikipedia. The table featured 3 columns and 100 observations. We used the importHTML function on Google Sheets to convert the table from Wikipedia into a csv file. The grain of the table is a song and its attributes. This table is different from the TikTok and Spotify datasets in that it only has three columns: No., Title, and Artist(s). The No. column represents the ranking of the songs, with rankings spanning from 1 to 100. A lower number means that the song ranked higher.\n\n\n\nTop Songs on Billboard Hot 100",
    "crumbs": [
      "Project Goals"
    ]
  },
  {
    "objectID": "cleaning.html",
    "href": "cleaning.html",
    "title": "Cleaning the Data",
    "section": "",
    "text": "Read the Tables from csv Files\nThese are the tables before cleaning and combining. Lots of unnecessary columns and inconsistent headings between the tables. Another issue to address is the quotations around the song titles on the Billboard chart. The song titles and artist names are also not consistent across tables.",
    "crumbs": [
      "Cleaning the Data"
    ]
  },
  {
    "objectID": "cleaning.html#challenges",
    "href": "cleaning.html#challenges",
    "title": "Cleaning the Data",
    "section": "Challenges",
    "text": "Challenges\nTwo challenges stood out to us, both involving the variations in the way that the song metadata is recorded on the charts. The same song can appear on different albums with slgiht variations of the title, or can have a featured artist listed in the title or as an additional artist, or could be a cover of another song, etc. As an example, the song “Enemy” by Imagine Dragons appears twice on the Spotify chart, once on the TikTok chart, and once on the Billboard chart:\n\nRSQLPython\n\n\n\n\nShow the code\nspotify_cleaned |&gt;\n  filter(str_detect(song_title, 'Enemy')) #filter for song titles containing \"Enemy\"\n\n\n\n  \n\n\n\nShow the code\ntiktok_cleaned |&gt;\n  filter(str_detect(song_title, 'Enemy'))\n\n\n\n  \n\n\n\nShow the code\nbillboard_cleaned |&gt;\n  filter(str_detect(song_title, 'Enemy'))\n\n\n\n  \n\n\n\n\n\n\n\nSpotify\nSELECT *\nFROM spotify_cleaned\nWHERE song_title LIKE '%Enemy%'\n\n\n\n2 records\n\n\n\n\n\n\n\n\nsong_title\nartist\nrank_s\ntempo\n\n\n\n\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons, JID, Arcane, League of Legends\n3\n77.011\n\n\nEnemy - From the series Arcane League of Legends\nImagine Dragons, Arcane, League of Legends\n171\n77.029\n\n\n\n\n\n\n\nTikTok\nSELECT *\nFROM tiktok_cleaned\nWHERE song_title LIKE '%Enemy%'\n\n\n\n1 records\n\n\n\n\n\n\n\n\nsong_title\nartist\nrank_t\ntempo\n\n\n\n\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons\n87\n77.011\n\n\n\n\n\n\n\nBillboard\nSELECT *\nFROM billboard_cleaned\nWHERE song_title LIKE '%Enemy%'\n\n\n\n1 records\n\n\nsong_title\nartist\nrank_b\n\n\n\n\nEnemy\nImagine Dragons and JID\n15\n\n\n\n\n\n\n\n\n\nShow the code\nGT(spotify_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\n\n\n\n\n\n\n\n\nsong_title\nartist\nrank_s\ntempo\n\n\n\n\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons, JID, Arcane, League of Legends\n3\n77.011\n\n\nEnemy - From the series Arcane League of Legends\nImagine Dragons, Arcane, League of Legends\n171\n77.029\n\n\n\n\n\n\n        \n\n\nShow the code\nGT(tiktok_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\n\n\n\n\n\n\n\n\nsong_title\nartist\nrank_t\ntempo\n\n\n\n\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons\n87\n77.011\n\n\n\n\n\n\n        \n\n\nShow the code\nGT(billboard_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\n\n\n\n\n\n\n\n\nrank_b\nsong_title\nartist\n\n\n\n\n15\nEnemy\nImagine Dragons and JID\n\n\n\n\n\n\n        \n\n\n\n\n\nAll three charts record the song title differently. The Spotify chart has two different versions of “Enemy” on it: one with JID and one without, so leaving those titles as is is fine. The TikTok and Billboard charts both have the version with JID, but the name of the song and artists listed are different. To handle these synonyms, we created a lookup table and applied it to each dataset. We chose to apply the dictionary to each individual table rather than a combined table so that when we combine the tables, songs with the same title and artists would be combined. The tables for the song titles and artist names were created in Google Sheets and uploaded to RStudio as csv files.\n\nChange Song Titles\nThe process in the three languages was essentially the same. We read the csv file and stored the resulting table. Then we merged/joined the lookup table with each chart. The lookup table has two columns: one containing the canonical names and another containing the alternative names.\n\nRSQLPython w/ MergePython w/ Replace\n\n\nRead the lookup table.\n\n\nShow the code\nsong_title_lookup &lt;- read_csv(\"initial_tables/dict_song_titles.csv\", show_col_types = FALSE)\nsong_title_lookup\n\n\n\n  \n\n\n\nWe used a left_join and joined on the song_title column of the song chart on the alt_name column of the lookup table. This join created a new column called canonical_name on the chart. mutate is used to replace the value in the song_title columns with the name in the canonical_name, if there is one. coalesce takes the first non-null value, so if the canonical_name column is empty, then the song title will not be replaced.\n\nspotify_cleaned &lt;- spotify_cleaned |&gt;\n  left_join(song_title_lookup, by = join_by(song_title == alt_name)) |&gt;\n  mutate(song_title = coalesce(canonical_name, song_title)) |&gt; #coalesce takes the first non-null value\n  select(song_title, artist, rank_s, tempo) #keep only relevant columns\n\n\ntiktok_cleaned &lt;- tiktok_cleaned |&gt;\n  left_join(song_title_lookup, by = join_by(song_title == alt_name)) |&gt;\n  mutate(song_title = coalesce(canonical_name, song_title)) |&gt;\n  select(song_title, artist, rank_t, tempo)\n\n\nbillboard_cleaned &lt;- billboard_cleaned |&gt;\n  left_join(song_title_lookup, by = join_by(song_title == alt_name)) |&gt; \n  mutate(song_title = coalesce(canonical_name, song_title)) |&gt;\n  select(song_title, artist, rank_b)\n\n\n\nRead the look table csv and create a table.\n\nCREATE OR REPLACE TABLE song_title_lookup AS\n  SELECT * \n  FROM 'initial_tables/dict_song_titles.csv';\n\nWe used UPDATE to avoid having to coalesce columns. This code checks if a song listed in the song title column in the chart is the same as a song listed in the alt_name column of the lookup table. If there is a match, then the song title is replaced with the song from the canonical_name column of the lookup table.\n\nUPDATE spotify_cleaned\n  SET song_title = song_title_lookup.canonical_name\n  FROM song_title_lookup\n  WHERE spotify_cleaned.song_title = song_title_lookup.alt_name\n\n\nUPDATE tiktok_cleaned\n  SET song_title = song_title_lookup.canonical_name\n  FROM song_title_lookup\n  WHERE tiktok_cleaned.song_title = song_title_lookup.alt_name\n\n\nUPDATE billboard_cleaned\n  SET song_title = song_title_lookup.canonical_name\n  FROM song_title_lookup\n  WHERE billboard_cleaned.song_title = song_title_lookup.alt_name\n\n\n\nWe have two different methods in Python here. This method uses .merge and is similar to the R version. The lookup table csv file is read. Then the chart table and the lookup table are left-merged on the song_title and alt_name. This creates two new columns in the chart called canonical_name and alt_name. If there is a value in the alt_name columns, the the value from the canonical_name column replaces the song_title.\n\nsong_syn = pd.read_csv('initial_tables/dict_song_titles.csv')\n\n# Spotify\nspotify_cleaned = spotify_cleaned.merge(song_syn, left_on = 'song_title', right_on = 'alt_name', how = 'left')\n\nspotify_cleaned['song_title'] = np.where( #if the alt_name column has a value then, replace song_title with canonical_name\n   spotify_cleaned['alt_name'].notna(), \n   spotify_cleaned['canonical_name'], \n   spotify_cleaned['song_title'])\n   \nspotify_cleaned = spotify_cleaned.drop(columns = ['canonical_name', 'alt_name']) # remove unnecessary columns\n\n\n# TikTok\ntiktok_cleaned = tiktok_cleaned.merge(song_syn, left_on = 'song_title', right_on = 'alt_name', how = 'left')\n\ntiktok_cleaned['song_title'] = np.where(\n   tiktok_cleaned['alt_name'].notna(), \n   tiktok_cleaned['canonical_name'], \n   tiktok_cleaned['song_title'])\n   \ntiktok_cleaned = tiktok_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n\n\n# Billboard\nbillboard_cleaned = billboard_cleaned.merge(song_syn, left_on = 'song_title', right_on = 'alt_name', how = 'left')\n\nbillboard_cleaned['song_title'] = np.where(\n   billboard_cleaned['alt_name'].notna(), \n   billboard_cleaned['canonical_name'], \n   billboard_cleaned['song_title'])\n   \nbillboard_cleaned = billboard_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n\n\n\nThe second Python method uses .replace. This method was my initial inclination regarding how to recode the charts, but is not the best appraoch to this problem. This method works be converting the lookup table csv file into a dictionary of keys and values. The alt_name column is set as the index and is mapped to the canonical_name column. to_dict converts the result to a dictionary.\n.replace looks for the song title in the keys of the dictionary and replaces the song_title with the canonical name from the dictionary. inplace modifies the original DataFrame directly. Using it spits out a “future warning” because there are planned changes for inplace.\n\n# import the table and convert to a dictionary using to.dict()\nsong_title_dict = pd.read_csv('initial_tables/dict_song_titles.csv', header=0).set_index('alt_name')['canonical_name'].to_dict()\n\n# replace the song_title with the canonical_name\nspotify_cleaned['song_title'].replace(song_title_dict, inplace = True)\ntiktok_cleaned['song_title'].replace(song_title_dict, inplace = True)\nbillboard_cleaned['song_title'].replace(song_title_dict, inplace = True)\n\n\n\n\n\n\nChange Artist Names\nThe we did the exact same thing but for the artist names. The lookup table in this instance had two columns: canonical_name and alt_name. The process was essentially the same as changing the song titles.\n\nRSQLPython w/ MergePython w/ Replace\n\n\n\ndict_artist &lt;- read_csv(\"initial_tables/dict_artist.csv\", show_col_types = FALSE)\ndict_artist\n\n\n  \n\n\n\n\nspotify_cleaned &lt;- spotify_cleaned |&gt;\n  left_join(dict_artist, by = join_by(artist == alt_name)) |&gt;\n  mutate(song_title = coalesce(canonical_name, song_title)) |&gt;\n  select(song_title, artist, rank_s, tempo)\n\n\ntiktok_cleaned &lt;- tiktok_cleaned |&gt;\n  left_join(dict_artist, by = join_by(artist == alt_name)) |&gt;\n  mutate(song_title = coalesce(canonical_name, song_title)) |&gt;\n  select(song_title, artist, rank_t, tempo)\n\n\nbillboard_cleaned &lt;- billboard_cleaned |&gt;\n  left_join(dict_artist, by = join_by(artist == alt_name)) |&gt;\n  mutate(song_title = coalesce(canonical_name, song_title)) |&gt;\n  select(song_title, artist, rank_b)\n\n\n\n\nCREATE TABLE dict_artist AS\n  SELECT * FROM 'initial_tables/dict_artist.csv';\n\n\nUPDATE spotify_cleaned\n  SET artist = dict_artist.canonical_name\n  FROM dict_artist\n  WHERE spotify_cleaned.artist = dict_artist.alt_name\n\n\nUPDATE tiktok_cleaned\n  SET artist = dict_artist.canonical_name\n  FROM dict_artist\n  WHERE tiktok_cleaned.artist = dict_artist.alt_name\n\n\nUPDATE billboard_cleaned \n  SET artist = dict_artist.canonical_name\n  FROM dict_artist\n  WHERE billboard_cleaned.artist = dict_artist.alt_name\n\n\n\n\ndict_artist = pd.read_csv('initial_tables/dict_artist.csv')\n\n# Spotify\nspotify_cleaned = spotify_cleaned.merge(dict_artist, left_on = 'artist', right_on = 'alt_name', how = 'left')\nspotify_cleaned['artist'] = np.where( #if the alt_name column has a value then, replace artist with canonical_name\n   spotify_cleaned['alt_name'].notna(), \n   spotify_cleaned['canonical_name'], \n   spotify_cleaned['artist'])\nspotify_cleaned = spotify_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n\n# TikTok\ntiktok_cleaned = tiktok_cleaned.merge(dict_artist, left_on = 'artist', right_on = 'alt_name', how = 'left')\ntiktok_cleaned['artist'] = np.where(\n   tiktok_cleaned['alt_name'].notna(), \n   tiktok_cleaned['canonical_name'], \n   tiktok_cleaned['artist'])\ntiktok_cleaned = tiktok_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n\n# Billboard\nbillboard_cleaned = billboard_cleaned.merge(dict_artist, left_on = 'artist', right_on = 'alt_name', how = 'left')\nbillboard_cleaned['artist'] = np.where(\n   billboard_cleaned['alt_name'].notna(), \n   billboard_cleaned['canonical_name'], \n   billboard_cleaned['artist'])\nbillboard_cleaned = billboard_cleaned.drop(columns = ['canonical_name', 'alt_name'])\n\n\n\n\ndict_artist = pd.read_csv('initial_tables/dict_artist.csv', header=0).set_index('alt_name')['canonical_name'].to_dict()\n\nspotify_cleaned['artist'].replace(dict_artist, inplace = True)\ntiktok_cleaned['artist'].replace(dict_artist, inplace = True)\nbillboard_cleaned['artist'].replace(dict_artist, inplace = True)\n\n\n\n\n\n\nExamples of the Changes\nWe did not print the tables above as they would have looked nearly identical to the original tables. Only a few songs out of about 900 songs were changed, so the changes would be difficult to see if the entire table was printed. Here is the same example from above using “Enemy.”\n\nRSQLPython\n\n\n\n\nShow the code\nspotify_cleaned |&gt;\n  filter(str_detect(song_title, 'Enemy')) #filter for song titles containing \"Enemy\"\n\n\n\n  \n\n\n\nShow the code\ntiktok_cleaned |&gt;\n  filter(str_detect(song_title, 'Enemy'))\n\n\n\n  \n\n\n\nShow the code\nbillboard_cleaned |&gt;\n  filter(str_detect(song_title, 'Enemy'))\n\n\n\n  \n\n\n\n\n\n\n\nSpotify\nSELECT *\nFROM spotify_cleaned\nWHERE song_title LIKE '%Enemy%'\n\n\n\n2 records\n\n\n\n\n\n\n\n\nsong_title\nartist\nrank_s\ntempo\n\n\n\n\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons, JID, Arcane, League of Legends\n3\n77.011\n\n\nEnemy - From the series Arcane League of Legends\nImagine Dragons, Arcane, League of Legends\n171\n77.029\n\n\n\n\n\n\n\nTikTok\nSELECT *\nFROM tiktok_cleaned\nWHERE song_title LIKE '%Enemy%'\n\n\n\n1 records\n\n\n\n\n\n\n\n\nsong_title\nartist\nrank_t\ntempo\n\n\n\n\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons\n87\n77.011\n\n\n\n\n\n\n\nBillboard\nSELECT *\nFROM billboard_cleaned\nWHERE song_title LIKE '%Enemy%'\n\n\n\n1 records\n\n\n\n\n\n\n\nsong_title\nartist\nrank_b\n\n\n\n\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons and JID\n15\n\n\n\n\n\n\n\n\n\nShow the code\nGT(spotify_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\n\n\n\n\n\n\n\n\nsong_title\nartist\nrank_s\ntempo\n\n\n\n\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons, JID, Arcane, League of Legends\n3\n77.011\n\n\nEnemy - From the series Arcane League of Legends\nImagine Dragons, Arcane, League of Legends\n171\n77.029\n\n\n\n\n\n\n        \n\n\nShow the code\nGT(tiktok_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\n\n\n\n\n\n\n\n\nsong_title\nartist\nrank_t\ntempo\n\n\n\n\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons\n87\n77.011\n\n\n\n\n\n\n        \n\n\nShow the code\nGT(billboard_cleaned.query('song_title.str.contains(\"Enemy\")', engine='python'))\n\n\n\n\n\n\n\n\nrank_b\nsong_title\nartist\n\n\n\n\n15\nEnemy (with JID) - from the series Arcane League of Legends\nImagine Dragons and JID",
    "crumbs": [
      "Cleaning the Data"
    ]
  },
  {
    "objectID": "joins.html",
    "href": "joins.html",
    "title": "Joins",
    "section": "",
    "text": "Now that the tables are cleaned and the synonyms are taken care of, we can join the three tables into one big table. One consideration when joining the tables, was ensuring that songs with the same name (but are actually different songs as indicated by the artist) were not combined. We used the song_title and the artist columns as parameters to prevent that mishap from occuring.\n\nExamples of Song Titles\nHere is a brief example of a song with the same name but different artists.\n\nRSQLPython\n\n\n\n\nShow the code\nspotify_cleaned |&gt;\n  filter(song_title == \"Cool for the Summer\")\n\n\n\n  \n\n\n\nShow the code\ntiktok_cleaned |&gt;\n  filter(song_title == \"Cool for the Summer\")\n\n\n\n  \n\n\n\n\n\n\n\nSpotify\nSELECT *\nFROM spotify_cleaned\nWHERE song_title = 'Cool for the Summer'\n\n\n\n1 records\n\n\nsong_title\nartist\nrank_s\ntempo\n\n\n\n\nCool for the Summer\nDemi Lovato\n61\n114.06\n\n\n\n\n\n\n\nTikTok\nSELECT *\nFROM tiktok_cleaned\nWHERE song_title = 'Cool for the Summer'\n\n\n\n1 records\n\n\nsong_title\nartist\nrank_t\ntempo\n\n\n\n\nCool for the Summer\nAlex D’Rosso\n49\n136.01\n\n\n\n\n\n\n\n\n\nSpotify\nspotify_cleaned.query(\"song_title == 'Cool for the Summer'\")\n\n\n              song_title       artist  rank_s   tempo\n360  Cool for the Summer  Demi Lovato      61  114.06\n\n\n\n\nTikTok\ntiktok_cleaned.query(\"song_title == 'Cool for the Summer'\")\n\n\n              song_title        artist  rank_t   tempo\n182  Cool for the Summer  Alex D'Rosso      49  136.01\n\n\n\n\n\n\n\nJoins/Merges\n\nRSQL PipedSQL w/ WITHPython\n\n\nWe used a full_join and joined by song_title and artist. A full_join meant that all observations from both tables would be kept. We wanted to keep all observations even if it meant that some songs would have NA values for the rankings on the other charts.\n\n# Join the TikTok and Spotify data by song title and call the new table s_and_t.\ns_and_t &lt;- spotify_cleaned |&gt;\n  full_join(tiktok_cleaned, by = join_by(song_title, artist))\ns_and_t\n\n\n  \n\n\n\n\n# Join the s_and_t table with the billboard table and call the new dataframe combined.\ncombined &lt;- s_and_t |&gt;\n  full_join(billboard_cleaned, by = join_by(song_title, artist))\ncombined\n\n\n  \n\n\n\nBecause both the Spotify and TikTok tables had a column called tempo, the resulting table had two columns for tempo: tempo.x and tempo.y. We used coalesce to combine the tempo columns into one since the tempo for an individual song would be the same no matter which chart it appears on. coalesce takes the tempo from the first non-missing value in the tempo.x and tempo.y columns and puts value in the new tempo column.\n\ncombined_cleaned &lt;- combined |&gt;\n  mutate(tempo = coalesce(tempo.x, tempo.y), .keep = \"unused\")\ncombined_cleaned\n\n\n  \n\n\n\n\n\nWe tried two different methods for joining the tables in SQL. This first method pipes the code blocks together. We used a FULL OUTER JOIN to join by song_title and artist. The FULL OUTER JOIN combines all records from both tables. It joins the data where there are matches and fills in null for the missing data. COALESCE is used here to combine the tempo, song titles, and artists.\n\n-- combine the spotify and tiktok tables\nCREATE OR REPLACE TABLE s_and_t AS \n    SELECT *, \n           COALESCE(tiktok_cleaned.tempo, spotify_cleaned.tempo) AS tempo_st, \n           COALESCE(tiktok_cleaned.song_title, spotify_cleaned.song_title) AS song_title_st, \n           COALESCE(tiktok_cleaned.artist, spotify_cleaned.artist) AS artist_st\n    FROM spotify_cleaned\n    FULL OUTER JOIN tiktok_cleaned ON tiktok_cleaned.song_title = spotify_cleaned.song_title AND tiktok_cleaned.artist = spotify_cleaned.artist\n;\n\n-- combine the spotify and tiktok table with the billboard table\nCREATE OR REPLACE TEMP TABLE s_t_b AS\n    SELECT *, \n           COALESCE(s_and_t.song_title_st, billboard_cleaned.song_title) AS song_title_real, \n           COALESCE(s_and_t.artist_st, billboard_cleaned.artist) AS artist_real\n    FROM s_and_t\n    FULL OUTER JOIN billboard_cleaned ON billboard_cleaned.song_title = s_and_t.song_title_st AND billboard_cleaned.artist = s_and_t.artist_st\n;\n-- select only the relevant columns\nCREATE OR REPLACE TABLE combined_cleaned_piped AS    \n  SELECT song_title_real AS song_title, \n         artist_real AS artist, \n         rank_s, \n         rank_t, \n         rank_b, \n         tempo_st AS tempo\n  FROM s_t_b\n\n\n\nThe second method uses WITH. The code creates several temporary tables that are then queried. The result of the query is stored as a new table.\n\n--combine the spotify and tiktok tables\nCREATE OR REPLACE TABLE combined_cleaned AS\n  WITH s_t AS (\n      SELECT *, \n             COALESCE(tiktok_cleaned.tempo, spotify_cleaned.tempo) AS tempo_st, \n             COALESCE(tiktok_cleaned.song_title, spotify_cleaned.song_title) AS song_title_st, \n             COALESCE(tiktok_cleaned.artist, spotify_cleaned.artist) AS artist_st\n      FROM spotify_cleaned\n      FULL OUTER JOIN tiktok_cleaned ON tiktok_cleaned.song_title = spotify_cleaned.song_title AND tiktok_cleaned.artist = spotify_cleaned.artist\n  ), s_t_b AS (\n--combine the spotify and tiktok table with the billboard table\n     SELECT *, \n             COALESCE(s_and_t.song_title_st, billboard_cleaned.song_title) AS song_title_real, \n             COALESCE(s_and_t.artist_st, billboard_cleaned.artist) AS artist_real\n      FROM s_and_t\n      FULL OUTER JOIN billboard_cleaned ON billboard_cleaned.song_title = s_and_t.song_title_st AND billboard_cleaned.artist = s_and_t.artist_st\n  )\n\nSELECT song_title_real AS song_title, \n         artist_real AS artist, \n         rank_s, \n         rank_t, \n         rank_b, \n         tempo_st AS tempo\nFROM s_t_b\n\n\n\nThe Python version of this operation uses an outer .merge to combine the tables so that all observations are accounted for. The code is read “inside-out,” so first the Spotify and TikTok tables are merged, then the Billboard table is merged with the result and called combined. In the process of merging, two new tempo columns (tempo_x and tempo_y) were created. We used .combine_first (very similar to COALESCE is SQL), which combines two dataframe objects by replacing a null value with a non-null value.\n\n#combine the three datasets\ncombined = pd.merge(billboard_cleaned, \n                   (pd.merge(spotify_cleaned, \n                             tiktok_cleaned, \n                             how='outer', \n                             on=['song_title', 'artist'])), \n                    how='outer', \n                    on=['song_title', 'artist'])\n\n#combine the tempo columns\ncombined = (combined\n        .assign(tempo = lambda df_: df_.tempo_x.combine_first(combined.tempo_y))\n        .drop(columns = ['tempo_x', 'tempo_y'])\n        [['song_title', 'artist', 'rank_s', 'rank_t', 'rank_b', 'tempo']]\n)\ncombined\n\n                                      song_title  ...    tempo\n0                                 'Til You Can't  ...      NaN\n1                               'Till I Collapse  ...  171.447\n2    1, 2, 3 (feat. Jason Derulo & De La Ghetto)  ...   94.968\n3    1, 2, 3 (feat. Jason Derulo & De La Ghetto)  ...   94.968\n4                     10 Things I Hate About You  ...  153.967\n..                                           ...  ...      ...\n924                                      traitor  ...  100.607\n925            up at night (feat. justin bieber)  ...  100.012\n926                                    vice city  ...   87.023\n927                           you broke me first  ...  124.148\n928                                        İmdat  ...  133.967\n\n[929 rows x 6 columns]",
    "crumbs": [
      "Joins"
    ]
  },
  {
    "objectID": "discr.html",
    "href": "discr.html",
    "title": "Discritized Table",
    "section": "",
    "text": "As explained earlier, the ranking system for each dataset was slightly different. The rank for songs on the Spotify chart rank_s ranges from 1 to 200. The value is the number that the Spotify algorithm uses to determine popularity. The rank for the TikTok charts rank_t ranges from 0 to 100. The value represents the highest rank on the chart that the song reached. A value of 1 would mean that the song reached the highest place on the chart. The documentation does not describe what a value of 0 means. We assume that it could mean that the song made it to the chart, but did not place highly. The rank for the Billboard chart rank_b ranges from 1 to 100. A value of 1 means that the song was ranked the highest on the chart and a value of 100 means that the song was last on the chart. Because these ranking systems are different, we created a table that has discretized values rather than numbers.\nThe term “Most popular” was applied to the 10% most popular songs on each chart, “Popular” to the top 50%, and “On chart” to the remaining values that were not NA.\n\nDiscretizing the Tables\n\nRSQLPython\n\n\nThis code calculates the percent rank for rank_s, rank_t, and rank_b, then uses a case_when to assign a label to each value.\n\ncombined_discretized &lt;- combined_cleaned |&gt; \n# Spotify\n  mutate(rank_s_percent = percent_rank(rank_s)) |&gt; # get the percent rank for each observation\n  mutate(rank_s_label = case_when( # spotify rank_s shows the highest the song reached on the chart (lower number = more popular)\n    rank_s_percent &lt; 0.10 ~ \"Most popular\",\n    rank_s_percent &lt;= 0.50 ~ \"Popular\",\n    rank_s_percent &gt; 0.50 ~ \"On chart\"\n    )) |&gt;\n  \n#TikTok\n  mutate(rank_t_percent = percent_rank(rank_t)) |&gt; # get the percent rank for each observation\n  mutate(rank_t_label = case_when( # tiktok rank_t shows the value that the algorithm eats (higher number = more popular)\n    rank_t_percent &gt; 0.90 ~ \"Most popular\",\n    rank_t_percent &gt;= 0.50 ~ \"Popular\",\n    rank_t_percent &lt; 0.50 ~ \"On chart\"\n    )) |&gt;\n\n#Billboard\n  mutate(rank_b_percent = percent_rank(rank_b)) |&gt; # get the percent rank for each observation\n  mutate(rank_b_label = case_when( # billboard rank_b shows the rank (lower number = high rank)\n    rank_b_percent &lt; 0.10 ~ \"Most popular\",\n    rank_b_percent &lt;= 0.50 ~ \"Popular\",\n    rank_b_percent &gt; 0.50 ~ \"On chart\"\n    )) |&gt;\n  \n  select(song_title, artist, rank_s, rank_s_label, rank_t, rank_t_label, rank_b, rank_b_label, tempo)\n\n\n\nThe function percent_rank is the relative position of the value in the sorted dataset. The statements below use percent_rank to determine if a song is the top x% and classifies the song accordingly. First a temporary table is made with the labels for the rank_s column. Then the labels for rank_t are added to that table, creating yet another temporary table in the process. Finally the labels for rank_b are added and the result is the final discretized table.\n\n--Spotify labels\nCREATE OR REPLACE TEMP TABLE disc_s AS\n  SELECT *,\n         percent_rank() OVER (ORDER BY rank_s) AS rank_s_percent,\n     CASE \n         WHEN rank_s_percent &lt; 10 THEN 'Most popular'\n         WHEN percent_rank() OVER (ORDER BY rank_s) &lt;= 50 THEN 'Popular'\n         ELSE 'On chart'\n     END\n    AS rank_s_label\n  FROM combined_cleaned\n;\n\n--TikTok labels added to the table with the Spotify labels\nCREATE OR REPLACE TEMP TABLE disc_s_t AS\n  SELECT *,\n         percent_rank() OVER (ORDER BY rank_t) AS rank_t_percent,\n     CASE \n         WHEN rank_t_percent &gt; 90 THEN 'Most popular'\n         WHEN percent_rank() OVER (ORDER BY rank_t) &gt;= 50 THEN 'Popular'\n         ELSE 'On chart'\n     END\n    AS rank_t_label\n  FROM disc_s\n\n;\n--Billboard labels added to the table with the Spotify and TikTok labels\nCREATE OR REPLACE TABLE discretized AS\n  SELECT *,\n     percent_rank() OVER (ORDER BY rank_b) AS rank_b_percent,\n     CASE \n         WHEN rank_b_percent &lt; 10 THEN 'Most popular'\n         WHEN percent_rank() OVER (ORDER BY rank_b) &lt;= 50 THEN 'Popular'\n         ELSE 'On chart'\n     END\n    AS rank_b_label\n  FROM disc_s_t\n\n\n\npd.qcut discretizes variables into buckets based on rank or quantiles. In this case, the data is being put into buckets based on the specified quantiles of 0%-10%, 10%-50%, and 50%-100%.\n\ncombined['rank_s_label'] = pd.qcut(combined['rank_s'], q=[0, 0.50, 0.90, 1], labels=[\"On chart\", \"Popular\", \"Most popular\"])\ncombined['rank_t_label'] = pd.qcut(combined['rank_t'], q=[0, 0.10, 0.50, 1], labels=[\"Most popular\", \"Popular\", \"On chart\"])\ncombined['rank_b_label'] = pd.qcut(combined['rank_b'], q=[0, 0.10, 0.50, 1], labels=[\"Most popular\", \"Popular\", \"On chart\"])\ncombined\n\n                                      song_title  ... rank_b_label\n0                                 'Til You Can't  ...      Popular\n1                               'Till I Collapse  ...          NaN\n2    1, 2, 3 (feat. Jason Derulo & De La Ghetto)  ...          NaN\n3    1, 2, 3 (feat. Jason Derulo & De La Ghetto)  ...          NaN\n4                     10 Things I Hate About You  ...          NaN\n..                                           ...  ...          ...\n924                                      traitor  ...          NaN\n925            up at night (feat. justin bieber)  ...          NaN\n926                                    vice city  ...          NaN\n927                           you broke me first  ...          NaN\n928                                        İmdat  ...          NaN\n\n[929 rows x 9 columns]\n\n\n\n\n\nThe discretized table makes the data easier to compare in a glance. While the following analysis will use the un-discretized table, this table is helpful in quickly verifying that we have sorted the rows appropriately.",
    "crumbs": [
      "Discritized Table"
    ]
  },
  {
    "objectID": "analysis.html",
    "href": "analysis.html",
    "title": "Analysis",
    "section": "",
    "text": "Songs on TikTok on both the Billboard and Spotify Charts\nWhat songs were popoular on TikTok that also appeared on both the Spotify and Billboard charts?\n\nRSQLPython\n\n\nBy excluding the NA values, this gives a dataframe of eleven songs that appear on all three charts.\n\n# make a new dataframe with popular songs on TikTok that also appear on other charts\nsongs_on_all_charts &lt;- combined_cleaned[complete.cases(combined_cleaned[ , c('rank_s', 'rank_t', 'rank_b')]), ]\n\n\n# make the table look nice\ngt(songs_on_all_charts) |&gt;\n  tab_header(\n    title=\"Popular Songs on TikTok appearing on Other Charts\"\n  )\n\n\n\n\n\n\n\nPopular Songs on TikTok appearing on Other Charts\n\n\nsong_title\nartist\nrank_s\nrank_t\nrank_b\ntempo\n\n\n\n\nHeat Waves\nGlass Animals\n1\n89\n1\n80.870\n\n\nAs It Was\nHarry Styles\n1\n96\n2\n173.930\n\n\nGlimpse of Us\nJoji\n1\n97\n52\n169.914\n\n\nLate Night Talking\nHarry Styles\n2\n93\n25\n114.996\n\n\nFirst Class\nJack Harlow\n2\n89\n6\n107.005\n\n\nBad Habits\nEd Sheeran\n3\n22\n13\n126.011\n\n\nWoman\nDoja Cat\n6\n89\n21\n107.998\n\n\nNeed to Know\nDoja Cat\n6\n85\n18\n130.041\n\n\nAbout Damn Time\nLizzo\n9\n92\n12\n108.965\n\n\nBad Habit\nSteve Lacy\n10\n86\n28\n168.946\n\n\nI Hate U\nSZA\n19\n79\n50\n106.703\n\n\n\n\n\n\n\n\n\nThis is essentially the same as the R version – excluding null values results in the songs that appeared on all charts.\n\nSELECT *,\nFROM combined_cleaned\nWHERE rank_s IS NOT NULL \n  AND rank_t IS NOT NULL \n  AND rank_b IS NOT NULL\n\n\nDisplaying records 1 - 10\n\n\nsong_title\nartist\nrank_s\nrank_t\nrank_b\ntempo\n\n\n\n\nHeat Waves\nGlass Animals\n1\n89\n1\n80.870\n\n\nBad Habits\nEd Sheeran\n3\n22\n13\n126.026\n\n\nNeed to Know\nDoja Cat\n6\n85\n18\n130.041\n\n\nGlimpse of Us\nJoji\n1\n97\n52\n169.914\n\n\nAbout Damn Time\nLizzo\n9\n92\n12\n108.966\n\n\nLate Night Talking\nHarry Styles\n2\n93\n25\n114.996\n\n\nFirst Class\nJack Harlow\n2\n89\n6\n106.998\n\n\nI Hate U\nSZA\n19\n79\n50\n106.703\n\n\nAs It Was\nHarry Styles\n1\n96\n2\n173.930\n\n\nWoman\nDoja Cat\n6\n89\n21\n107.998\n\n\n\n\n\n\n\nAgain, this excludes the null values.\n\nall_charts = combined[combined[['rank_s', 'rank_t', 'rank_b']].notnull().all(1)]\n\nGT(all_charts) # makes the table look nice\n\n\n\n\n\n\n\nsong_title\nartist\nrank_s\nrank_t\nrank_b\ntempo\n\n\n\n\nAbout Damn Time\nLizzo\n9.0\n92.0\n12.0\n108.965\n\n\nAs It Was\nHarry Styles\n1.0\n96.0\n2.0\n173.93\n\n\nBad Habit\nSteve Lacy\n10.0\n86.0\n28.0\n168.946\n\n\nBad Habits\nEd Sheeran\n3.0\n22.0\n13.0\n126.011\n\n\nFirst Class\nJack Harlow\n2.0\n89.0\n6.0\n107.005\n\n\nGlimpse of Us\nJoji\n1.0\n97.0\n52.0\n169.914\n\n\nHeat Waves\nGlass Animals\n1.0\n89.0\n1.0\n80.87\n\n\nI Hate U\nSZA\n19.0\n79.0\n50.0\n106.703\n\n\nLate Night Talking\nHarry Styles\n2.0\n93.0\n25.0\n114.996\n\n\nNeed to Know\nDoja Cat\n6.0\n85.0\n18.0\n130.041\n\n\nWoman\nDoja Cat\n6.0\n89.0\n21.0\n107.998\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\nSongs Appearing on Charts\nHow many songs appeared on all three charts? How many on just TikTok and Spotify? How many on just Billboard and Spotify? etc.\n\nRSQL w/ PivotSQL w/ FilterPython\n\n\nTo calculate these values, we first created new columns (one for each chart) that held either TRUE or FALSE depending on whether the song appeared on the corresponding chart. These new columns allowed us to use the summarize function to calculate how many true values appeared in each combination of columns. The results count how many songs appear on the various combinations of charts.\n\ncombined_cleaned |&gt;\n  mutate( #create new columns that identify whether a song appears on the chart using TRUE/FALSE\n    on_tiktok = !is.na(rank_t), #identifies the non-NA songs appearing on the tiktok chart\n    on_spotify = !is.na(rank_s), #identifies the non-NA songs appearing on the spotify\n    on_billboard = !is.na(rank_b) #identifies the non-NA songs appearing on the billboard chart\n  ) |&gt;\n  summarize( #calculates the total number of TRUE values for each combination of charts\n    only_tiktok = sum(on_tiktok & !on_spotify & !on_billboard),\n    only_spotify = sum(!on_tiktok & on_spotify & !on_billboard),\n    only_billboard = sum(!on_tiktok & !on_spotify & on_billboard),\n    only_tiktok_and_spotify = sum(on_tiktok & on_spotify & !on_billboard),\n    only_tiktok_and_billboard = sum(on_tiktok & !on_spotify & on_billboard),\n    only_spotify_and_billboard = sum(!on_tiktok & on_spotify & on_billboard),\n    all_three = sum(on_tiktok & on_spotify & on_billboard)\n  )\n\n\n  \n\n\n\n\n\nWe came up with two different methods to find the answer. The first uses CTEs and pivots to calculate the counts.\n\nCREATE OR REPLACE TABLE total_counts_with AS\nWITH cte_1 AS(\n-- unpivot the table to make it longer\n  UNPIVOT combined_cleaned\n    ON rank_s, rank_t, rank_b\n    INTO\n      NAME charts\n      VALUE rank\n), cte_2 AS(\n-- the value in the rank column does not matter for this analysis, so we did not include it in SELECT\n  SELECT song_title, artist, charts, tempo\n  FROM cte_1\n), cte_3 AS(\n-- pivot to make the table wider\n  PIVOT_WIDER cte_2\n  ON charts\n  USING first(charts)\n), cte_4 AS(\n-- concatenate the three charts into one column\n  SELECT CONCAT(rank_s, ', ', rank_t, ', ', rank_b) AS charts\n  FROM cte_3\n)\n-- group by the new charts column and count how many songs appear on each combination of charts\n  SELECT charts, COUNT(*) AS counts\n  FROM cte_4\n  GROUP BY charts\n\n\n\nThe second method uses COUNT(*), FILTER, and WHERE. Each line counts the number of rows that meet the condition in WHERE.\n\nCREATE OR REPLACE TABLE total_counts AS\nSELECT COUNT(*) FILTER (WHERE rank_s IS NOT NULL AND rank_t IS NULL AND rank_b IS NULL) AS only_s,\n       COUNT(*) FILTER (WHERE rank_s IS NULL AND rank_t IS NOT NULL AND rank_b IS NULL) AS only_t,\n       COUNT(*) FILTER (WHERE rank_s IS NULL AND rank_t IS NULL AND rank_b IS NOT NULL) AS only_b,\n       COUNT(*) FILTER (WHERE rank_s IS NOT NULL AND rank_t IS NOT NULL AND rank_b IS NULL) AS only_spotify_and_tiktok,\n       COUNT(*) FILTER (WHERE rank_s IS NULL AND rank_t IS NOT NULL AND rank_b IS NOT NULL) AS only_tiktok_and_billboard,\n       COUNT(*) FILTER (WHERE rank_s IS NOT NULL AND rank_t IS NULL AND rank_b IS NOT NULL) AS only_spotify_and_billboard,\n       COUNT(*) FILTER (WHERE rank_s IS NOT NULL AND rank_t IS NOT NULL AND rank_b IS NOT NULL) AS all_three\nFROM combined_cleaned\n\n\n\nTo create the output, we created a new dataframe with the labels as column headers and all the values set to zero. The we replaced each of the zeros with the appropriate counts. We used .sum() to count the non NA values for each column.\n\n(combined.\n  melt(id_vars = [\"song_title\"], var_name = \"charts\", value_name = \"rank\")\n)\n\n                                       song_title  ...                                     rank\n0                                  'Til You Can't  ...                             Cody Johnson\n1                                'Till I Collapse  ...                        Eminem, Nate Dogg\n2     1, 2, 3 (feat. Jason Derulo & De La Ghetto)  ...                              Sofía Reyes\n3     1, 2, 3 (feat. Jason Derulo & De La Ghetto)  ...  Sofía Reyes, Jason Derulo, De La Ghetto\n4                      10 Things I Hate About You  ...                                Leah Kate\n...                                           ...  ...                                      ...\n4640                                      traitor  ...                                  100.607\n4641            up at night (feat. justin bieber)  ...                                  100.012\n4642                                    vice city  ...                                   87.023\n4643                           you broke me first  ...                                  124.148\n4644                                        İmdat  ...                                  133.967\n\n[4645 rows x 3 columns]\n\n\n\ndata = {'only_spotify': [0], 'only_tiktok': [0], 'only_billboard': [0], 'only_spotify_and_tiktok': [0], 'only_tiktok_and_billboard': [0], 'only_spotify_and_billboard': [0], 'all_three': [0]}\ntotals = pd.DataFrame(data)\n\ntotals['only_spotify'] = [(combined['rank_s'].notna() &\n                           combined['rank_t'].isna() &\n                           combined['rank_b'].isna()).sum()]\ntotals['only_tiktok'] = [(combined['rank_s'].isna() &\n                          combined['rank_t'].notna() &\n                          combined['rank_b'].isna()).sum()]\ntotals['only_billboard'] = [(combined['rank_s'].isna() &\n                             combined['rank_t'].isna() &\n                             combined['rank_b'].notna()).sum()]\ntotals['only_spotify_and_tiktok'] = [(combined['rank_s'].notna() &\n                                      combined['rank_t'].notna() &\n                                      combined['rank_b'].isna()).sum()]\ntotals['only_tiktok_and_billboard'] = [(combined['rank_s'].isna() &\n                                        combined['rank_t'].notna() &\n                                        combined['rank_b'].notna()).sum()]\ntotals['only_spotify_and_billboard'] = [(combined['rank_s'].notna() &\n                                         combined['rank_t'].isna() &\n                                         combined['rank_b'].notna()).sum()]\ntotals['all_three'] = [(combined['rank_s'].notna() &\n                        combined['rank_t'].notna() &\n                        combined['rank_b'].notna()).sum()]\n\nGT(totals)\n\n\n\n\n\n\n\nonly_spotify\nonly_tiktok\nonly_billboard\nonly_spotify_and_tiktok\nonly_tiktok_and_billboard\nonly_spotify_and_billboard\nall_three\n\n\n\n\n577\n212\n70\n40\n0\n19\n11\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\nTikTok Songs and Tempo\nDid popular songs on TikTok have higher tempos? Many viral trends on TikTok involve creators doing a short dance. We wonder if there is a relationship to the tempo of songs and what which songs are popular. We used a simple scatter plot to visualize the data.\n\nRSQLPython\n\n\n\ncombined_cleaned |&gt;\n  ggplot(data = combined_cleaned, mapping = aes(x = rank_t, y = tempo)) +\n  geom_point() +\n  labs(x = \"Song Rank on TikTok\", y = \"Tempo of Song\")\n\n\n\n\n\n\n\n\n\n\nNothing here since SQL doesn’t visualize.\n\n\n\ncombined.plot.scatter(x=\"rank_t\", y=\"tempo\").set(xlabel=\"Rank on TikTok\", ylabel=\"Tempo (BPM)\", title=\"Tempo of Popular Songs on TikTok\")\n\n\n\n\n\n\n\n\nAs seen from the plot, there does not appear to be a correlation between songs being popular on TikTok and tempo. In the original data, some of the songs had a rank of 0. The documentation does not describe why that some songs included in the chart have a rank of 0.",
    "crumbs": [
      "Analysis"
    ]
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "Conclusion",
    "section": "",
    "text": "That’s it. The data has been wrangled and analysed. I am challenge I feel proud of is discretizing the data. The way that the numbers representing the ranks couldn’t be directly compared because they not representing the same info made me go bonkers. The labels were nice to look at. I am also proud of all the pivoting I did in SQL in the “Songs Appearing on Charts” section of the Analysis. I now realize I should have done something like that in R and Python as well. Oh well",
    "crumbs": [
      "Conclusion"
    ]
  }
]